# Simple workflow for deploying versioned static content to GitHub Pages
name: Build and deploy github pages with versioning

on:
  # Runs on pushes to version branches
  push:
    branches:
      - "v*" # Matches v1, v2, v3, etc.
      - "main" # Optional: keep main branch
    paths: ["src/**"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build_and_deploy:
    strategy:
      matrix:
        node-version: [18.x]
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for version detection

      # Build library and docs
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm run build:lib
      - run: npm run build:docs

      # Get major version from branch name
      - name: Get major version
        id: get_version
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          echo "Current branch: $BRANCH_NAME"

          if [[ $BRANCH_NAME =~ ^v[0-9]+$ ]]; then
            # Branch name is already in format v1, v2, etc.
            VERSION=$BRANCH_NAME
          elif [[ $BRANCH_NAME == "main" ]]; then
            # For main branch, try to get version from package.json or git tag
            if [ -f "package.json" ]; then
              FULL_VERSION=$(node -p "require('./package.json').version")
              MAJOR_VERSION=$(echo $FULL_VERSION | cut -d. -f1)
              VERSION="v$MAJOR_VERSION"
            else
              # Fallback to latest git tag
              FULL_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "1")
              MAJOR_VERSION=$(echo $FULL_VERSION | cut -d. -f1)
              VERSION="v$MAJOR_VERSION"
            fi
          else
            # Fallback: extract version from branch name or use branch name
            VERSION=$(echo $BRANCH_NAME | grep -oE 'v[0-9]+' || echo $BRANCH_NAME)
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Detected major version: $VERSION"

      # Setup major versioned directory structure
      - name: Setup versioned docs
        run: |
          VERSION=${{ steps.get_version.outputs.version }}
          mkdir -p ./versioned-docs/$VERSION
          cp -r ./docs/* ./versioned-docs/$VERSION/

          # Create or update root index.html that redirects to latest major version
          cat > ./versioned-docs/index.html << EOF
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <title>Documentation</title>
            <meta http-equiv="refresh" content="0; url=./$VERSION/">
            <link rel="canonical" href="./$VERSION/">
          </head>
          <body>
            <p>Redirecting to <a href="./$VERSION/">latest documentation ($VERSION)</a>...</p>
          </body>
          </html>
          EOF

          # Create 404.html from the versioned index
          cp ./versioned-docs/$VERSION/index.html ./versioned-docs/404.html

      # Optional: Checkout and preserve existing major versions from gh-pages branch
      - name: Preserve existing versions
        run: |
          # Create a temporary directory for existing content
          mkdir -p ./temp-existing

          # Check if gh-pages branch exists
          if git ls-remote --heads origin gh-pages | grep -q gh-pages; then
            echo "gh-pages branch exists, fetching existing versions..."
            git fetch origin gh-pages
            
            # Create a temporary branch to access gh-pages content safely
            git checkout -b temp-gh-pages origin/gh-pages 2>/dev/null || {
              echo "Failed to checkout gh-pages, continuing without preserving versions"
              git checkout main
              exit 0
            }
            
            # Copy existing major version folders (but not root files)
            for dir in v*; do
              if [ -d "$dir" ] && [ "$dir" != "${{ steps.get_version.outputs.version }}" ]; then
                echo "Preserving existing major version: $dir"
                cp -r "$dir" ./temp-existing/
              fi
            done
            
            # Switch back to main branch and clean up
            git checkout main
            git branch -D temp-gh-pages 2>/dev/null || true
          else
            echo "gh-pages branch doesn't exist yet. This might be the first deployment."
          fi

          # Copy preserved versions to versioned-docs (if any exist)
          if [ -d "./temp-existing" ] && [ "$(ls -A ./temp-existing 2>/dev/null)" ]; then
            echo "Copying preserved versions..."
            cp -r ./temp-existing/* ./versioned-docs/ 2>/dev/null || true
          else
            echo "No existing versions to preserve."
          fi

          # List all major versions for debugging
          echo "Available major versions after preservation:"
          ls -la ./versioned-docs/

      - name: Setup Pages
        uses: actions/configure-pages@v3
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v1
        with:
          # Upload versioned docs folder
          path: "./versioned-docs"
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2
